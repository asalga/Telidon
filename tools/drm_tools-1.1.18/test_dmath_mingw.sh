#!/bin/bash
#
#  MINGW version
#
#
#  use dos2unix to strip \r out of \r\n
#  change to tests as 0.0 formats as e000 On windows, but e00 on linux
#
#
#  test script for dmath testbed features.
#  This script uses accudate, from drm_tools, available from:
#    http://sourceforge.net/projects/drmtools/
#
#  Note the <<'EOD', the quoted input delimiter disables substitution within that input
#
##
##
NEWPROG=./dmath
TMPDIR='C:\\temp\\'
TESTED=0
PASSED=0
RM=/bin/rm
DIFF=/usr/bin/diff #must be Gnu diff

#
# use this if the program is supposed to run without error
#
dotest ()
{
 cat > ${TMPDIR}new.txt <<'EOD'
EOD
 cat ${TMPDIR}input1.txt | eval $NEWPROG | dos2unix >${TMPDIR}new.txt
 let TESTED+=1
 $DIFF -q ${TMPDIR}new.txt ${TMPDIR}old.txt
 if [ $? -eq 0 ]
 then
   echo -n " $TESTED Pass "
   let PASSED+=1
 else 
   echo -n " $TESTED Fail "
   diff ${TMPDIR}new.txt ${TMPDIR}old.txt
 fi
}


echo
echo "testing "
echo
echo " N OK?  Test"
#
# DO NOT EDIT THESE LINES.  OK to add onto the end.
#
cat >${TMPDIR}input1.txt <<'EOD'
1
1+3
1-3
1*3
1/3
10
=A
20
=B
30
=C
$A
$A+3
$A-3
$A*3
$A/3
($A)
($A+3)
($A-3)
($A*3)
($A/3)
+($A)
+($A+3)
+($A-3)
+($A*3)
+($A/3)
+$A
+$A+3
+$A-3
+$A*3
+$A/3
-$A
-$A+3
-$A-3
-$A*3
-$A/3
-($A)
-($A+3)
-($A-3)
-($A*3)
-($A/3)
2%3
trc(1.1)
trc(-1.1)
lid(1.1)
lid(-1.1)
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
1.000000
4.000000
-2.000000
3.000000
0.333333
10.000000
20.000000
30.000000
10.000000
13.000000
7.000000
30.000000
3.333333
10.000000
13.000000
7.000000
30.000000
3.333333
10.000000
13.000000
7.000000
30.000000
3.333333
10.000000
13.000000
7.000000
30.000000
3.333333
-10.000000
-7.000000
-13.000000
-30.000000
-3.333333
-10.000000
-13.000000
-7.000000
-30.000000
-3.333333
0.666667
1.000000
-1.000000
2.000000
-2.000000
EOD

dotest; echo "General"

cat >${TMPDIR}input1.txt <<'EOD'
sin(0)
cos(0)
tan(0)
asin(sin(0))
acos(cos(0))
atan(tan(0))
sin(d2r(90))
cos(d2r(90))
tan(d2r(90))
r2d(asin(sin(d2r(90))))
r2d(acos(cos(d2r(90))))
r2d(atan(tan(d2r(90))))
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
0.000000
1.000000
0.000000
0.000000
0.000000
0.000000
1.000000
0.000000
16331778728383844.000000
90.000000
90.000000
90.000000
EOD
dotest; echo "Trig functions"

cat >${TMPDIR}input1.txt <<'EOD'
2^3
2^-3
-2^3
-2^-3
log(0)
ln(0)
log(-1)
ln(-1)
e10(log(10))
ee(ln(10))
log(e10(10))
ln(ee(10))
log(10)
=Z
e10(-$Z)
sinh(0)
sinh(1)
sinh(10)
cosh(0)
cosh(1)
cosh(10)
tanh(0)
tanh(1)
tanh(10)
xint
digits 0
not(0xFF)
not(not(0xFF))
and(0xFF,0x18)
or(0x81,0x18)
xor(0xFF,0x18)
shl(0x10,4)
shr(0x10,4)
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
8.000000
0.125000
-8.000000
-0.125000
-inf
-inf
ERROR
ERROR
10.000000
10.000000
10.000000
10.000000
1.000000
0.100000
0.000000
1.175201
11013.232875
1.000000
1.543081
11013.232920
0.000000
0.761594
1.000000
ffffff00
ff
18
99
e7
100
1
EOD

dotest; echo "Logs, exponents, hyperbolic functions"

cat >${TMPDIR}input1.txt <<'EOD'
2++3
2+-3
2-+3
2--3
2*+3
2*-3
5/+3
5/-3
5%+3
5%-3
2^+3
2^-3
+2++3
+2+-3
+2-+3
+2--3
+2*+3
+2*-3
+5/+3
+5/-3
+5%+3
+5%-3
+2^+3
+2^-3
-2++3
-2+-3
-2-+3
-2--3
-2*+3
-2*-3
-5/+3
-5/-3
-5%+3
-5%-3
-2^+3
-2^-3
(+2++3)
(+2+-3)
(+2-+3)
(+2--3)
(+2*+3)
(+2*-3)
(+5/+3)
(+5/-3)
(+5%+3)
(+5%-3)
(+2^+3)
(+2^-3)
(-2++3)
(-2+-3)
(-2-+3)
(-2--3)
(-2*+3)
(-2*-3)
(-5/+3)
(-5/-3)
(-5%+3)
(-5%-3)
(-2^+3)
(-2^-3)
+log(10)
-log(10)
max(-max(1,2),+max(3,4))
max(+max(1,2),-max(3,4))
5
=A
-$A
+$A
max($A,$A)
max(-$A,-$A)
max($A,-$A)
max(-$A,$A)
max(+$A,+$A)
max($A,+$A)
max(+$A,$A)
max(($A),$A)
max((-$A),-$A)
max(($A),-$A)
max((-$A),$A)
max((+$A),+$A)
max(($A),+$A)
max((+$A),$A)
max($A,($A))
max(-$A,(-$A))
max($A,(-$A))
max(-$A,($A))
max(+$A,(+$A))
max($A,(+$A))
max(+$A,($A))
max(($A),($A))
max((-$A),(-$A))
max(($A),(-$A))
max((-$A),($A))
max((+$A),(+$A))
max(($A),(+$A))
max((+$A),($A))
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
5.000000
-1.000000
-1.000000
5.000000
6.000000
-6.000000
1.666667
-1.666667
0.666667
-0.666667
8.000000
0.125000
5.000000
-1.000000
-1.000000
5.000000
6.000000
-6.000000
1.666667
-1.666667
0.666667
-0.666667
8.000000
0.125000
1.000000
-5.000000
-5.000000
1.000000
-6.000000
6.000000
-1.666667
1.666667
-0.666667
0.666667
-8.000000
-0.125000
5.000000
-1.000000
-1.000000
5.000000
6.000000
-6.000000
1.666667
-1.666667
0.666667
-0.666667
8.000000
0.125000
1.000000
-5.000000
-5.000000
1.000000
-6.000000
6.000000
-1.666667
1.666667
-0.666667
0.666667
-8.000000
-0.125000
1.000000
-1.000000
4.000000
2.000000
5.000000
-5.000000
5.000000
5.000000
-5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
-5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
-5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
-5.000000
5.000000
5.000000
5.000000
5.000000
5.000000
EOD

dotest; echo "Unary"

cat >${TMPDIR}input1.txt <<'EOD'
1 - 6 - 7
1000 / 10 / 10
1 + 3 * 2
3 * 2 + 1
1 - 3 * 2
3 * 2 - 1
1 + 4 / 2
4 / 2 + 1
1 - 4 / 2
4 / 2 - 1
1 + 4 ^ 2
4 ^ 2 + 1
1 - 4 ^ 2
4 ^ 2 - 1
1 + 4 % 2
4 % 2 + 1
1 - 4 % 2
4 % 2 - 1
1 * 4 % 2
4 % 2 * 1
1 / 5 % 2
5 % 2 / 1
2 +  3 ? 4
4 ?  2 + 3
9 -  3 ? 4
4 ?  9 - 3
3 *  3 ? 4
4 ?  3 * 3
15 / 3 ? 4
4 ?  3 / 0.2
(2 +  3) ? 4
4 ?  (2 + 3)
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
-12.000000
10.000000
7.000000
7.000000
-5.000000
5.000000
3.000000
3.000000
-1.000000
1.000000
17.000000
17.000000
-15.000000
15.000000
1.000000
1.000000
1.000000
-1.000000
0.000000
0.000000
0.100000
0.500000
1.000000
-1.000000
1.000000
-1.000000
1.000000
-1.000000
1.000000
-1.000000
1.000000
-1.000000
EOD

dotest; echo "Precedence"

cat >${TMPDIR}input1.txt <<'EOD'
1
=a
2
>a
3
>a
4
>a
$A[1]
$A[2]
$A[3]
$A[4]
$A[-1]
$A[-2]
$A[-3]
$A[-4]
$A[min(max(-4,-20),-1)]
$A[min(max(-4,-3),-1)]
$A[min(max(-4,2),-1)]
len($A[])
sum($A[])
sm2($A[])
5+dim($A[],10)
$A[]=10
len($A[])
sum($A[])
sm2($A[])
cat($D[],2)
cat($D[],3)
$D[1]
$D[2]
$D[3]
$A[3]=6
$A[4]=7
$D[1,2]=$A[3,4]
$D[1]
$D[2]
len($A[3,4])
sum($A[3,4])
sm2($A[3,4])
sum($A[-8,-7])
sm2($A[-8,-7])
idx($A[1,3])
$A[1]
$A[2]
$A[3]
dim($A[],3)
dim($B[],3)
$B[]=$A[1,3]
$B[]*3
<B
inv($A[])
map($B[],$A[])
<B
ump($B[],$A[])
<B
dim($A[],6)+dim($B[],6)
$B[1]=324
$B[2]=982
$B[3]=-2398
$B[4]=-24
$B[5]=935
$B[6]=2398
$A[]=$B[]
srt($A[])
<A
$A[]=$B[]
srt($A[2,4])
<A
$A[]=$B[]
six($A[2,4])
<A
$A[]=$B[]
six($A[])
map($B[],$A[])
<B
ini($A[],1,2,3,4,5,6,7,8)
sum($A[])
cat($A[],9,10)
sum($A[])
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
1.000000
2.000000
3.000000
4.000000
1.000000
2.000000
3.000000
4.000000
4.000000
3.000000
2.000000
1.000000
1.000000
2.000000
4.000000
4.000000
10.000000
30.000000
5.000000
10.000000
10.000000
100.000000
1000.000000
2.000000
3.000000
0.000000
2.000000
3.000000
6.000000
7.000000
2.000000
6.000000
7.000000
10.000000
13.000000
85.000000
13.000000
85.000000
0.000000
1.000000
2.000000
3.000000
0.000000
0.000000
3.000000
1.000000
   1 3.000000
   2 6.000000
   3 9.000000
0.000000
1.000000
   1 9.000000
   2 6.000000
   3 3.000000
1.000000
   1 3.000000
   2 6.000000
   3 9.000000
0.000000
324.000000
982.000000
-2398.000000
-24.000000
935.000000
2398.000000
6.000000
0.000000
   1 -2398.000000
   2 -24.000000
   3 324.000000
   4 935.000000
   5 982.000000
   6 2398.000000
6.000000
0.000000
   1 324.000000
   2 -2398.000000
   3 -24.000000
   4 982.000000
   5 935.000000
   6 2398.000000
6.000000
0.000000
   1 324.000000
   2 3.000000
   3 4.000000
   4 2.000000
   5 935.000000
   6 2398.000000
6.000000
0.000000
1.000000
   1 -2398.000000
   2 -24.000000
   3 324.000000
   4 935.000000
   5 982.000000
   6 2398.000000
8.000000
36.000000
10.000000
55.000000
EOD

dotest; echo "Arrays"

cat >${TMPDIR}input1.txt <<'EOD'
dim($a[],4)
dim($b[],4)
$A=1
$A[2]=2
$A[3]=3
$A[4]=4
$A[-1]
$A[-2]
$A[-3]
$A[-4]
$A[1+(4-3)]=$A[1+(4-3)]
$A[1+(4-3)]=$A[1+$A[1]*(4-3)]
$B[]=$A[]
$B[1]
$B[2]
$B[3]
$B[4]
inv($A[])
$A[1]
$A[2]
$A[3]
$A[4]
inv($A[])
inv($A[2,4])
$A[2]
$A[3]
$A[4]
$A[]=$B[]
del($A[])
len($A[])
$A[1]
dim($a[],4)
$A[]=$B[]
del($A[2,3])
$A[1]
$A[2]
dim($a[],4)
$A[]=$B[]
del($A[1,2])
$A[1]
$A[2]
dim($a[],4)
$A[]=$B[]
del($A[3,4])
$A[1]
$A[2]
del($A[1,1])
$A[1]
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
0.000000
0.000000
1.000000
2.000000
3.000000
4.000000
4.000000
3.000000
2.000000
1.000000
2.000000
2.000000
4.000000
1.000000
2.000000
3.000000
4.000000
0.000000
4.000000
3.000000
2.000000
1.000000
0.000000
0.000000
4.000000
3.000000
2.000000
4.000000
1.000000
1.000000
0.000000
0.000000
4.000000
2.000000
1.000000
4.000000
0.000000
4.000000
2.000000
3.000000
4.000000
0.000000
4.000000
2.000000
1.000000
2.000000
1.000000
2.000000
EOD

dotest; echo "Assignment"

cat >${TMPDIR}input1.txt <<'EOD'
eng
digits 3
-0
nnz
-0
sci
-0
eng
digits 6
pnz
-0
nnz
-0
digits 9
pnz
-0
nnz
-0
pnz
digits 0
1
digits 9
1
sci
digits 0
1
digits 6
1
sint
3
-3
digits 0
-3
uint
10
0x10
xint
10
16
oint
10
64
digits 4
10
xint
10
sint
10
-10
123.4
-123.4
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
0.000
-0.000
-0.000e+00
0.000000
-0.000000
0.000000000
-0.000000000
1
1.000000000
1e+00
1.000000e+00
000003
-000003
-3
10
16
a
10
12
100
0012
000a
0010
-0010
0123
-0123
EOD

dotest; echo "Notation/Precision"

#
# This ONLY works if the binary was compiled with -DUSETOK !!!
#

cat >${TMPDIR}input1.txt <<'EOD'
dim($a[],tok(a[]))
$a[]=a[]
4+a[1]
4+b[2]
4+c[3]
4+a[a[1]]
$a=c[3]
$a[1,2]=a[2,3]
$a[1]
$a[2]
sln(a[])
sln(a[1,2])
tln(a[])
tln(a[1,2])
tln(b[])
tln(b[1,2])
tln(c[])
tln(c[1,2])
tln(c[-2,-1])
dim($a[],tok(d[]))
$a[]=d[]
<A
dim($a[],tok(e[]))
tix($a[],e[])
<A
tcx($a[],e[])
<A
tix($a[2,6],e[1,5])
<A
tcx($a[1,5],e[1,5])
<A
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
0.000000
3.000000
5.000000
26.000000
337.000000
5.000000
333.000000
2.000000
2.000000
3.000000
11.000000
11.000000
3.000000
2.000000
6.000000
4.000000
9.000000
6.000000
6.000000
0.000000
5.000000
   1 nan
   2 inf
   3 inf
   4 -inf
   5 nan
0.000000
0.000000
   1 5.000000
   2 1.000000
   3 3.000000
   4 4.000000
   5 2.000000
   6 6.000000
0.000000
   1 1.000000
   2 3.000000
   3 4.000000
   4 5.000000
   5 2.000000
   6 6.000000
0.000000
   1 1.000000
   2 5.000000
   3 1.000000
   4 3.000000
   5 4.000000
   6 2.000000
0.000000
   1 1.000000
   2 3.000000
   3 4.000000
   4 5.000000
   5 2.000000
   6 2.000000
EOD

dotest; echo "Tokens   (must have been compiled with -DUSETOK)"

cat >${TMPDIR}input1.txt <<'EOD'
dim($A[],3)
dim($B[],3)
dim($C[],3)
$C[1]=11
$C[2]=22
$C[3]=33
$A[]=$C[]
e10(log($A[]))
$A[1]
$A[2]
$A[3]
$A[]=$C[]
ee(ln($A[]))
$A[1]
$A[2]
$A[3]
$A[]=$C[]
$A[1]
$A[2]
$A[3]
$A[]+1
$A[1]
$A[2]
$A[3]
1+$A[]
$A[1]
$A[2]
$A[3]
$A[]-1
$A[1]
$A[2]
$A[3]
1-$A[]
$A[1]
$A[2]
$A[3]
$A[]*-1
$A[1]
$A[2]
$A[3]
2*$A[]
$A[1]
$A[2]
$A[3]
$A[]/2
$A[1]
$A[2]
$A[3]
66/$A[]
$A[1]
$A[2]
$A[3]
$A[]%4
$A[1]
$A[2]
$A[3]
$A[]=$C[]
11%$A[]
$A[1]
$A[2]
$A[3]
$A[]^2
$A[1]
$A[2]
$A[3]
2^$A[]
$A[1]
$A[2]
$A[3]
$A[]=$C[]
$A[]?22
$A[1]
$A[2]
$A[3]
$A[]=$C[]
22?$A[]
$A[1]
$A[2]
$A[3]
max($A[]*0+$C[],22)
$A[1]
$A[2]
$A[3]
$A[]=$C[]
max(0*$A[]+$C[],22)
$A[1]
$A[2]
$A[3]
$A[]=$C[]
min(0*$A[]+$C[],22)
$A[1]
$A[2]
$A[3]
$C[1]=d2r(30)
$C[2]=d2r(45)
$C[3]=d2r(60)
$A[]=$C[]
sin($A[])+1
$A[1]
$A[2]
$A[3]
$A[]=$C[]
1+cos($A[])
$A[1]
$A[2]
$A[3]
$A[]=$C[]
1+tan($A[])
$A[1]
$A[2]
$A[3]
$A[]=$C[]
r2d(atan(tan($A[])))
$A[1]
$A[2]
$A[3]
$A[]=$C[]
r2d(asin(sin($A[])))
$A[1]
$A[2]
$A[3]
$A[]=$C[]
r2d(acos(cos($A[])))
$A[1]
$A[2]
$A[3]
$C[1]=1.234
$C[2]=-1.234
$C[3]=1.501
$A[]=$C[]
1+abs($A[])
$A[1]
$A[2]
1+chs($A[])
$A[1]
$A[2]
$A[]=$C[]
1+trc($A[])
$A[1]
$A[2]
$A[3]
$A[]=$C[]
lid($A[])
$A[1]
$A[2]
$A[3]
$A[]=$C[]
1+rnd($A[])
$A[1]
$A[2]
$A[3]
$C[1]=0
$C[2]=1
$C[3]=10
$A[]=$C[]
sinh($A[])
<A
$A[]=$C[]
cosh($A[])
<A
$A[]=$C[]
tanh($A[])
<A
$A[]=-$C[]
<A
$A[]=-rnd($C[])
<A
quit
EOD
# unary math works, but only on Numeric vectors, not String vectors
# also like everything else in array math, it sticks to the vector
# it is applied to, so the following changes the sign of everything in $C

cat >${TMPDIR}old.txt <<'EOD'
0.000000
0.000000
0.000000
11.000000
22.000000
33.000000
3.000000
0.000000
11.000000
22.000000
33.000000
3.000000
0.000000
11.000000
22.000000
33.000000
3.000000
11.000000
22.000000
33.000000
0.000000
12.000000
23.000000
34.000000
0.000000
13.000000
24.000000
35.000000
0.000000
12.000000
23.000000
34.000000
0.000000
-11.000000
-22.000000
-33.000000
0.000000
11.000000
22.000000
33.000000
0.000000
22.000000
44.000000
66.000000
0.000000
11.000000
22.000000
33.000000
0.000000
6.000000
3.000000
2.000000
0.000000
0.500000
0.750000
0.500000
3.000000
0.000000
0.000000
0.500000
0.333333
0.000000
0.000000
0.250000
0.111111
0.000000
1.000000
1.189207
1.080060
3.000000
0.000000
-1.000000
0.000000
1.000000
3.000000
0.000000
1.000000
0.000000
-1.000000
0.000000
22.000000
22.000000
33.000000
3.000000
0.000000
22.000000
22.000000
33.000000
3.000000
0.000000
11.000000
22.000000
22.000000
0.523599
0.785398
1.047198
3.000000
0.000000
1.500000
1.707107
1.866025
3.000000
0.000000
1.866025
1.707107
1.500000
3.000000
0.000000
1.577350
2.000000
2.732051
3.000000
0.000000
30.000000
45.000000
60.000000
3.000000
0.000000
30.000000
45.000000
60.000000
3.000000
0.000000
30.000000
45.000000
60.000000
1.234000
-1.234000
1.501000
3.000000
0.000000
2.234000
2.234000
0.000000
-1.234000
-1.234000
3.000000
0.000000
2.000000
0.000000
2.000000
3.000000
0.000000
2.000000
-2.000000
2.000000
3.000000
0.000000
2.000000
0.000000
3.000000
0.000000
1.000000
10.000000
3.000000
0.000000
   1 0.000000
   2 1.175201
   3 11013.232875
3.000000
0.000000
   1 1.000000
   2 1.543081
   3 11013.232920
3.000000
0.000000
   1 0.000000
   2 0.761594
   3 1.000000
3.000000
   1 0.000000
   2 -1.000000
   3 -10.000000
3.000000
   1 0.000000
   2 1.000000
   3 10.000000
EOD

dotest; echo "Array Math"

cat >${TMPDIR}input1.txt <<'EOD'
4+$A
>>one
5*$B
>>two
$A=10
$B=20
<< one
<< two
??
xx one
??
xx two
??
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
4.000000
0.000000
10.000000
20.000000
14.000000
100.000000
Stored programs: 2
one: 4+$A
two: 5*$B
Stored programs: 1
two: 5*$B
Stored programs: 0
EOD

dotest; echo "Stored operations"

cat >${TMPDIR}input1.txt <<'EOD'
dim($A[],3)
$-
2
$A[]=$-
<A
2
$A[$-,3]=-$-*10
<A
10
-4-$--6
2
e10(-$-)
quit
EOD
cat >${TMPDIR}old.txt <<'EOD'
0.000000
0.000000
2.000000
3.000000
   1 2.000000
   2 2.000000
   3 2.000000
2.000000
2.000000
   1 2.000000
   2 -20.000000
   3 -20.000000
10.000000
-20.000000
2.000000
0.010000
EOD

dotest; echo "Previous Result"


echo "---------------------------------------------"
echo "Passed: $PASSED/$TESTED"

#/bin/rm ${TMPDIR}input1.txt
#/bin/rm ${TMPDIR}input2.txt
#/bin/rm ${TMPDIR}pieces.txt
